package com.anan_kobayashi.scalefree_network.backend;

import java.io.IOException;
import java.io.Serializable;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/*
 *
 * Created by marian on 5/7/2017.
 *
 */
public abstract class Network<T> implements Serializable {
    private static int node_id_counter = 0;
    protected ArrayList<Node<T>> nodes;

    public Network()
    {
        this.reset();
    }

    protected void reset()
    {
        node_id_counter = 0;
        this.nodes = new ArrayList<>();
    }

    public ArrayList<Node<T>> get_nodes() {
        return this.nodes;
    }

    /**
     * Add a single Node to the Network
     * @param n The Node which will be added to the Network
     */
    void add_node(Node<T> n) {
        this.nodes.add(n);
        n.setId(node_id_counter++);
    }

    void add_as_node(T n)
    {
        Node<T> new_node = new Node<>();
        new_node.setId(node_id_counter++);
        new_node.setElement(n);
        this.nodes.add(new_node);
    }

    /**
     * Connect two Nodes with an Edge
     * @param n1 First Node
     * @param n2 Second Node
     */
    void add_edge(Node<T> n1, Node<T> n2) {
        n1.neighbours.add(n2);
        n2.neighbours.add(n1);
    }

    public Node<T> get_node(int index) {
        return this.get_nodes().get(index);
    }


    /**
     * BFS Algorithm with Traceback-Ability to get the shortest path and the distance from n1 to n2
     *
     * @param n1 Start the search from this node
     * @param n2 Find the shortest path to this node
     * @return Distance between both nodes; -1 if not found
     */
    public int calculate_distance(Node<T> n1, Node<T> n2) {
        Map<Node<T>, Node<T>> visited_nodes = new IdentityHashMap<>(); // value is the parent node of key to traceback the path
        Queue<Node<T>> queued_nodes = new PriorityQueue<>();

        visited_nodes.put(n1, n1); // first node is the parent of itself
        queued_nodes.add(n1);
        int distance = 0;
        Node<T> current;

        while (!queued_nodes.isEmpty()) {
            current = queued_nodes.poll();
            if (current == n2) // found
            {
                Node<T> traceback = n2; // set the traceback to find the way back
                while (traceback != n1) {
                    traceback = visited_nodes.get(traceback);
                    distance++;
                }
                return distance;
            }
            for (Node<T> neighbor : current.get_neighbours()) {
                if (!visited_nodes.containsKey(neighbor)) {
                    visited_nodes.put(neighbor, current);
                    queued_nodes.add(neighbor);
                }
            }
        }
        return -1; // not found
    }


    /**
     * the SIF-Format is needed by CytoScape to draw the Network. The format is super-easy and looks like this:
     * > a line which only consists one name is an isolated node. for example:
     * nodeA
     * > a line which consists two names and some other string between are two nodes with a connection. for example:
     * nodeB abc nodeC
     * > one node can be connected to several other nodes, indicated by:
     * nodeB abc nodeC nodeD nodeA
     *
     * @param filepath the filepath where to save the data
     * @throws IOException
     */
    public void export_to_sif(String filepath) throws IOException {

        Path file = Paths.get("Networks\\" + filepath);

        LinkedList<String> lines = new LinkedList<String>();

        // we iterate through all nodes and inside them we iterate through all neighbors
        for (Node<T> n : this.get_nodes()) {
            String line = "";
            line += String.valueOf(n.getId()) + " xx ";
            for (Node<T> neighbor : n.neighbours) {
                line += String.valueOf(neighbor.getId() + " ");
            }
            lines.add(line);
        }

        // then we just write the items_list with all strings to the file
        Files.write(file, lines, Charset.forName("UTF-8"));
    }

    /**
     * Imports a file generated by the export_to_sif() function to this datastructure
     *
     * @param filepath the file to read from
     * @throws IOException
     */
    public void import_from_sif(String filepath) throws IOException {
        Path file = Paths.get("Networks\\" + filepath);
        this.nodes = new ArrayList<>();
        Node.reset_id_counter();

        List<String> strings = new ArrayList<>();

        Stream<String> s = Files.lines(file, StandardCharsets.UTF_8);

        strings = s.collect(Collectors.toList());
        // add as many nodes as there are lines in the file
        for (int i = 0; i < strings.size(); i++) {
            this.nodes.add(new Node<T>());
        }


        for (int i = 0; i < strings.size(); i++) {
            String str = strings.get(i).split(" xx ")[1];
            for (String neighbour : str.split(" ")) {
                this.nodes.get(i).neighbours.add(this.nodes.get(Integer.decode(neighbour)));
            }
        }
    }

    /**
     * Getter for the Node with the highgest Degree
     * @return Reference to the Node
     */
    public Node<?> get_highest_degree_node() {
        int highest_degree = 0;
        Node<?> highest_degree_node = null;
        for (Node<?> n : this.get_nodes()) {
            if (n.getDegree() > highest_degree) {
                highest_degree_node = n;
                highest_degree = n.getDegree();
            }
        }
        return highest_degree_node;
    }

    /**
     * Getter for a List of all nodes with given Degree
     * @param degree the degree to search for
     * @return ArrayList with References to all Nodes with the input Degree
     */
    public ArrayList<Node<?>> get_nodes_by_degree(int degree) {
        ArrayList<Node<?>> nodes = new ArrayList<>();
        for (Node<?> n : this.get_nodes()) {
            if (n.getDegree() == degree) {
                nodes.add(n);
            }
        }
        return nodes;
    }
}
